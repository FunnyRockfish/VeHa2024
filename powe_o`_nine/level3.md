## На третьем уровне нам требуется реализовать уровень 2 для приложения на PTX. 
Само работающее решение мы не успели сделать, однако, чтобы показать, что мы разобрались в теме, приведём ниже алгоритм работы для уровня 3. 

### Шаг 1:
- **Определение процессов**: каждый поток моделируем как отдельный процесс (`proctype`), исполняющий последовательность инструкций PTX.
- **Регистры и переменные**: регистры PTX (`%r`, `%p`) отображаются на переменные в Promela.
  
  Пример:
  ```promela
  int r20, r18, r15;
  ```

- **Инструкции PTX**: каждая инструкция PTX транслируется в соответствующее действие в Promela.

  Пример:
  ```ptx
  add.s32 %r20, %r18, %r15;
  ```
  Соответствует:
  ```promela
  r20 = r18 + r15;
  ```

### Шаг 2:  
- **Условные переходы и предикаты**: использование конструкций `if..fi` для моделирования условных инструкций и предикатных регистров.

  Пример:
  ```ptx
  setp.gt.s32 %p1, %r4, 0;
  @%p1 bra BB0_2;
  ```
  Соответствует:
  ```promela
  p1 = (r4 > 0);
  if
  :: p1 -> goto BB0_2;
  :: else -> skip;
  fi;
  ```

**Шаг 3: Реализация работы с масками**

В PTX управление ветвлениями осуществляется с помощью масок и предикатного выполнения. Для моделирования этого механизма:

- **Маска варпы**: для каждой варпы определяем массив булевых значений `active[N]`, где `N` — размер варпы (32 потока). Этот массив отражает активность потоков.

  ```promela
  bool active[warp_size];
  ```

- **Стек масок**: для поддержки вложенных ветвлений используется стек масок.

  ```promela
  bool mask_stack[MAX_DEPTH][warp_size];
  int sp = 0; // это указатель стека
  ```

- **Обновление масок при ветвлениях**:
  - При входе в ветвление сохраняем текущую маску в стек и обновляем ее в соответствии с результатом предиката.
  - При завершении ветвления восстанавливаем маску из стека.

- **Выполнение инструкций с учетом маски**: при выполнении каждой инструкции проверяем, активен ли поток.

  ```promela
  for (i : 0 .. warp_size) {
    if
    :: active[i] -> 
        // выполнение инструкции потоком i
    :: else -> skip
    fi;
  }
  ```
